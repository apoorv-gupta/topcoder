#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

class ApplesAndPears {
   public:
      void makepre(vector<vector < int > > &a, const vector<string> &b, int k, char c) {
         for(int i=0;i<k;++i){
            int cnt=0;
            for(int j=0;j<k;++j){
               if(b[i][j]==c) cnt++;
               a[i+1][j+1]=a[i][j+1]+cnt;
            }
         }
      }
      int findelems(const vector<vector < int > > &a, int r1, int r2, int c1, int c2) {
         int ans=a[r2][c2];
         ans-=a[r2][c1];
         ans-=a[r1][c2];
         ans+=a[r1][c1];
         return ans;
      }
      int getArea(vector <string> b, int k) {
         int n = b.size();
         vector<vector < int > > a(n+1,vector < int >(n+1)), p(n+1,vector < int >(n+1));
         makepre(a,b,n,'A');
         makepre(p,b,n,'P');
         int ans=0;
         int tap=findelems(a,0,n,0,n);
         int tpe=findelems(p,0,n,0,n);
         int blanks=n*n-tap-tpe;
         for(int r1=0;r1<=n;++r1)
            for(int c1=0;c1<=n;++c1)
               for(int r2=r1+1;r2<=n;++r2)
                  for(int c2=c1+1;c2<=n;++c2){
                     int ap=findelems(a,r1,r2,c1,c2);
                     int pe=findelems(p,r1,r2,c1,c2);
                     int ar=(r2-r1)*(c2-c1);
                     int dots = ar-ap-pe;
                     if(blanks>=ar) {
                        if(dots==ar)   ans=max(ans,ar);
                        if((ap+pe)<=k) ans=max(ans,ar);
                     }
                     if(tap>=ar) {
                        if(ap==ar) ans=max(ans,ar);
                        else if(blanks && ((pe*2+dots)<=k)) ans=max(ans,ar);
                     }
                     if(tpe>=ar) {
                        if(pe==ar) ans=max(ans,ar);
                        else if(blanks && ((ap*2+dots)<=k)) ans=max(ans,ar);
                     }
                  }
         return ans;
      }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, int p2) {
   cout << "Test " << testNum << ": [" << "{";
   for (int i = 0; int(p0.size()) > i; ++i) {
      if (i > 0) {
         cout << ",";
      }
      cout << "\"" << p0[i] << "\"";
   }
   cout << "}" << "," << p1;
   cout << "]" << endl;
   ApplesAndPears *obj;
   int answer;
   obj = new ApplesAndPears();
   clock_t startTime = clock();
   answer = obj->getArea(p0, p1);
   clock_t endTime = clock();
   delete obj;
   bool res;
   res = true;
   cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
   if (hasAnswer) {
      cout << "Desired answer:" << endl;
      cout << "\t" << p2 << endl;
   }
   cout << "Your answer:" << endl;
   cout << "\t" << answer << endl;
   if (hasAnswer) {
      res = answer == p2;
   }
   if (!res) {
      cout << "DOESN'T MATCH!!!!" << endl;
   } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
      cout << "FAIL the timeout" << endl;
      res = false;
   } else if (hasAnswer) {
      cout << "Match :-)" << endl;
   } else {
      cout << "OK, but is it right?" << endl;
   }
   cout << "" << endl;
   return res;
}
int main() {
   bool all_right;
   all_right = true;

   vector <string> p0;
   int p1;
   int p2;
   {
      // ----- test -1  -----
      string t0[] = {"."};
      p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
      p1 = 0;
      p2 = 1;
      all_right = KawigiEdit_RunTest(-1, p0, p1, true, p2) && all_right;
      // ------------------
   }

   {
      // ----- test 0 -----
      string t0[] = {".A","P."};
      p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
      p1 = 0;
      p2 = 1;
      all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
      // ------------------
   }

   {
      // ----- test 1 -----
      string t0[] = {".A","P."};
      p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
      p1 = 1;
      p2 = 2;
      all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
      // ------------------
   }

   {
      // ----- test 2 -----
      string t0[] = {".PP","PPA","PAP"};
      p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
      p1 = 3;
      p2 = 6;
      all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
      // ------------------
   }

   {
      // ----- test 3 -----
      string t0[] = {"A.P.PAAPPA","PPP..P.PPP","AAP.A.PAPA","P.PA.AAA.A","...PA.P.PA","P..A.A.P..","PAAP..A.A.","PAAPPA.APA",".P.AP.P.AA","..APAPAA.."};
      p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
      p1 = 10;
      p2 = 21;
      all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
      // ------------------
   }

   if (all_right) {
      cout << "You're a stud (at least on the example cases)!" << endl;
   } else {
      cout << "Some of the test cases had errors." << endl;
   }
   return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
